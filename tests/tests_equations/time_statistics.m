load "src/isomorphism/quadratic_equivalence.m";



// Magma Script to Benchmark Isomorphism Algorithm from a Database
//
// This script reads files generated by the SageMath script, reconstructs
// the isomorphic quaternion algebras, and times Magma's built-in
// IsIsomorphic function.

// ==============================================================================
//  TIMING FUNCTION
// ==============================================================================

function iso_quat_alg_timer(A, B)
    // This function times Magma's IsIsomorphic function and includes a timeout.
    //
    // Args:
    //   A, B: Two quaternion algebras over the rational field.
    // Returns:
    //   The CPU time taken in seconds, or -1.0 if the time exceeds 10 seconds.
    
    start_time := Cputime();
    
    // Call Magma's intrinsic function to find the isomorphism.
    // The 'Isomorphism' parameter ensures the map is computed.
    is_iso, iso_map := IsIsomorphic(A, B : Isomorphism:=true);
    
    end_time := Cputime();
    
    time_taken := end_time - start_time;
    
    // Check for timeout
    if time_taken gt 10.0 then
        return -1.0;
    end if;
    
    // Security check, should always be true with the generated data.
    if not is_iso then
        error "Fatal Error: Algebras are not isomorphic, data is corrupt.";
    end if;
    
    return time_taken;
end function;

// ==============================================================================
//  FUNCTION TO READ A DATA FILE AND COMPUTE MEAN TIME
// ==============================================================================

function MeanTime(t)
    // Reads a data file for a given bit length 't', runs the timer on each
    // isomorphic pair, and returns the mean computation time and timeout count.
    //
    // Args:
    //   t: The bit length corresponding to the data file.
    // Returns:
    //   A tuple <mean, timeout_count>.
    
    db_directory := "database/"; // Note the forward slash for path construction
    filename := db_directory cat IntegerToString(t) cat "_bits_iso.txt";

    // First, check if the file can be opened.
    F := Open(filename, "r");
    if Type(F) eq BoolElt and F eq false then
        printf "Error: Data file not found at '%o'\n", filename;
        return 0.0, 0; // Return zero values on error
    end if;

    // Read the entire file's content into a string, then split it into lines.
    // This is a more robust method than looping with IsEof.
    lines := Split(Read(filename), "\n");

    // Filter out any empty lines that might exist in the file.
    numeric_lines := [l : l in lines | #l gt 0];

    if #numeric_lines mod 4 ne 0 then
        printf "Warning: The file %o has an incomplete block of numbers.\n", filename;
    end if;

    timings := [];
    timeout_count := 0;
    
    i := 1;
    j := 1;
    // Loop through the lines in chunks of 4.
    while i le #numeric_lines - 3 do

        printf IntegerToString(j);
        // Convert string lines to integers
        a_val := StringToInteger(numeric_lines[i]);
        b_val := StringToInteger(numeric_lines[i+1]);
        c_val := StringToInteger(numeric_lines[i+2]);
        d_val := StringToInteger(numeric_lines[i+3]);
        
        // Recreate the quaternion algebras over the field of rationals (QQ)
        // We use negative coefficients as per the generation logic.
        A := QuaternionAlgebra< Rationals() | -a_val, -b_val >;
        B := QuaternionAlgebra< Rationals() | -c_val, -d_val >;

        // Measure the time for the isomorphism from B to A
        time_taken := iso_quat_alg_timer(A, B);
        
        if time_taken eq -1.0 then
            timeout_count +:= 1;
        else
            Append(~timings, time_taken);
        end if;

        i +:= 4;
        j +:=1;
    end while;

    // Calculate and return the results
    mean := #timings gt 0 select &+timings / #timings else 0;
    
    return mean, timeout_count;
    
end function;






// ==============================================================================
//  FUNCTION TO READ A DATA FILE AND COMPUTE MEAN TIME OF QUADRATIC EQUIVALENCE
// ==============================================================================

function MeanTimeEquivalence(t)
    // Reads a data file for a given bit length 't', runs the timer on each
    // isomorphic pair, and returns the mean computation time and timeout count.
    //
    // Args:
    //   t: The bit length corresponding to the data file.
    // Returns:
    //   A tuple <mean, timeout_count>.
    
    db_directory := "database/"; // Note the forward slash for path construction
    filename := db_directory cat IntegerToString(t) cat "_bits_iso.txt";

    // First, check if the file can be opened.
    F := Open(filename, "r");
    if Type(F) eq BoolElt and F eq false then
        printf "Error: Data file not found at '%o'\n", filename;
        return 0.0, 0; // Return zero values on error
    end if;

    // Read the entire file's content into a string, then split it into lines.
    // This is a more robust method than looping with IsEof.
    lines := Split(Read(filename), "\n");

    // Filter out any empty lines that might exist in the file.
    numeric_lines := [l : l in lines | #l gt 0];

    if #numeric_lines mod 4 ne 0 then
        printf "Warning: The file %o has an incomplete block of numbers.\n", filename;
    end if;

    timings := [];
    timeout_count := 0;
    
    i := 1;
    j := 1;
    // Loop through the lines in chunks of 4.
    while i le #numeric_lines - 3 do

        
        // Convert string lines to integers
        a := StringToInteger(numeric_lines[i]);
        b := StringToInteger(numeric_lines[i+1]);
        c := StringToInteger(numeric_lines[i+2]);
        d := StringToInteger(numeric_lines[i+3]);
        
        // Recreate the quaternion algebras over the field of rationals (QQ)
        // We use negative coefficients as per the generation logic.
        S1 := DiagonalMatrix( Rationals(),[-a, -b,-a*b]);
        S2 := DiagonalMatrix( Rationals(),[-c, -d,-c*d]);

        // Measure the time for the isomorphism from B to A
        start_time := Cputime();

        printf "factorize a\n";
        Fa := Factorization(a);
        printf "factorize b\n";
        Fb := Factorization(b);
        printf "factorize c\n";
        Fc := Factorization(c);
        printf "factorize d\n";
        Fd := Factorization(d);
        fact := (Fa*Fb*Fc*Fd)^2;
        printf "all fact done.\n";
        res := Equivalence(S1,S2:FAC := fact);


        end_time := Cputime();
        time_taken := end_time - start_time;

        if time_taken eq -1.0 then
            timeout_count +:= 1;
        else
            Append(~timings, time_taken);
        end if;

        i +:= 4;
        j +:=1;
    end while;

    // Calculate and return the results
    mean := #timings gt 0 select &+timings / #timings else 0;
    
    return mean;
    
end function;


[ 10   , 20   , 30   , 40   , 50   , 60   , 70    , 75    , 80   , 85  ,  90    , 95    , 100  ];
[ 0.014, 0.022, 0.036, 0.078, 0.151, 0.300, 0.578 , 0.893,  1.469, 1.527, 2.000 , 2.591 , 3.585];
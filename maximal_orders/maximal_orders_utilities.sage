load("utilities/utilities.sage")
load("utilities/algebra_type.sage")



#------------------------------------------------------------------------------------------
#
#            MAXIMAL ORDERS UTILITIES
#
#------------------------------------------------------------------------------------------


## Modular matrix kernel

def Z_mod_span_by_rows(M):
    """
    Compute a Z-basis for the Z-span of the rows of a rational matrix.
    
    INPUT:
    -- M -- a rational matrix of size m x n
            M = ( x1 )
                ( x3 )  where each xi ∈ Q^n
                ( ⋮ )
                ( xm )
    
    OUTPUT:
    -- Zbasis -- a list [e1, e2, ..., er] of vectors in Q^n such that
                 Zx1 + Zx2 + ... + Zxm = Ze1 ⊕ Ze2 ⊕ ... ⊕ Zer
                 
                 In other words, the Z-module generated by the rows of M
                 equals the free Z-module with basis {e1, ..., er}.
    
    ALGORITHM:
    This function leverages SageMath's internal submodule() method which 
    computes a generating set for the Z-submodule of Q^n spanned by the 
    given vectors.

    REMARKS:
    - The output basis is typically in a reasonably good form due to 
      SageMath's internal algorithms, though it is not necessarily 
      LLL-reduced
    """
    n = M.ncols()
    d  = M.denominator()
    A = d*M
    L = ZZ^n
    submod = L.submodule(A.rows())
    Zbasis = submod.basis()
    return [e/d for e in Zbasis]


def intersection_Z_mod(list_mat):
    """
    INPUT:
    -- list_mat -- a list of integer matrices M1, M2, ..., Mk with the same number of columns
    Let denote for 1 <= j <= k:
    Ij = sub Z-module of Q^n generated by the rows of Mj
        = Z * Mj_row_1 + Z * Mj_row_2 + ... + Z * Mj_row_mj

    OUTPUT:
    -- Zbasis -- a list e1, e2, ..., er of vectors in Q^n such that
    I1 intersect I2 intersect ... intersect Ik = Ze1 ⊕ Ze2 ⊕ ... ⊕ Zer

    REMARKS:
    - Uses SageMath's inner functions for Z-module operations. The basis 
    e1, e2, ..., er should be in reasonably good form...
    """
    n = list_mat[0].ncols()
    L = ZZ^n
    submod = L.submodule(list_mat[0].rows())
    for A in list_mat[1:]:
        K = L.submodule(A.rows())
        submod = submod.intersection(K)
    Zbasis = submod.basis()
    return [e for e in Zbasis]
    

def kernel_mod_non_split(M,d):
    """
    INPUT :
        -- M -- a rectangular matrix of size m x n with coefficients in Z
        -- d -- a positive integer
    OUTPUT :
        -- Zbasis_sol -- a list of vector of Z^n which is a Z basis of the set {X in Z^n | MX = 0 mod d}
    
    ALGORITHM :
        We compute the Smith Form of M : U*M*V = D diag pseudo diagonal (rectangular matrix) with U,V invertible in Mn(Z) or Mm(Z)
        then M X = 0 mod d iff UMX = 0 mod d 
                           iff DV^{-1}X=0 mod d
                           iff X = VY where D Y = 0 mod d
        So we compute easily a basis of solution for Y , that is where r = min(n,m):
            (d1/gcd(d1,d),0,..,0) (0,d2/gcd(d2,d),0,..,0) ... (0,..,0, dr/gcd(dr,d))  
            and if n>m complete with (0,..,0,1,0,.,0) .. (0,0,0,..,0,1)
    """
    m = M.nrows()
    n = M.ncols()
    N = min(n,m)


    D,U,V = M.smith_form(transformation=True)


    Y = [vector(ZZ, [d/gcd(d, D[i][i]) if j == i else 0 for j in range(n)]) for i in range(N)]
    for i in range(N,n):
        Y.append(vector(ZZ, [1 if j == i else 0 for j in range(n)]))
    X = [V* Y[i] for i in range(n)]
    return X


def kernel_mod(M, d):
    """
    INPUT :
    -- M -- a rectangular matrix of size m x n with coefficients in Z
    -- d -- a positive integer
    OUTPUT :
    -- Zbasis_sol -- a list of vectors of Z^n which is a Z basis of the set {X in Z^n | MX = 0 mod d}
    ALGORITHM :
    If m>>n to optimize we first split in blocks
    M = ( B1
          .
          .
          Bk )
    with B1,..,Bk square matrix of size n, except maybe Bk not square
    we use kernel_mod_non_split(Bi,d) for all i and then
    use the inner sage function to compute a Z basis of an intersection of Z module.
    """
    m = M.nrows()
    n = M.ncols()
    
    # If matrix is not tall enough to benefit from blocking, use direct method
    if m <= n :
        return kernel_mod_non_split(M, d)
    
    # Compute blocks
    blocks = []
    current_row = 0
    
    # Create blocks of size n x n (square blocks)
    while current_row + n <= m:
        block = M[current_row:current_row + n, :]
        blocks.append(block)
        current_row += n
    
    # Handle remaining rows (if any) - this block might not be square
    if current_row < m:
        remaining_block = M[current_row:m, :]
        blocks.append(remaining_block)
    
    # Compute kernel for each block
    list_mat = []
    for B in blocks:
        Zbasis_ker_B_mod_d = kernel_mod_non_split(B, d)
        if len(Zbasis_ker_B_mod_d) > 0:
            # Convert list of vectors to matrix format (vectors as rows)
            matrix_format = Matrix(ZZ, Zbasis_ker_B_mod_d)
            list_mat.append(matrix_format)
        else:
            # If kernel is empty, return empty basis
            return []
    
    # If no valid matrices, return empty
    if len(list_mat) == 0:
        return []
    
    # Compute intersection of all Z-modules
    Zbasis_final = intersection_Z_mod(list_mat)
    return Zbasis_final







## Latices and left order 

def lattice_LLL(B,Zbasis_I): 
    """
    INPUT :
        -- B -- a finite dimensional algebra over Q
        -- Zbasis_I -- a list [e1,..,eN] which is a Q-basis of B and representing the lattice I := Ze1⊕... ⊕ZeN 
    OUTPUT : 
        -- Zbasis_J -- a list [f1,..,fN] which is a Q-basis of B and representing the lattice J := Zf1⊕... ⊕ZfN such that J = I and Zbasis_J is "simpler"
    """
    basis_B = list(B.basis())
    N = dimension(B)

    rows = []
    for e in Zbasis_I:
        rows.append(get_coefficients(e,B))
    A = Matrix(QQ,rows)
    M = A.LLL()
    Zbasis_J = [ sum(M[i][k]*basis_B[k] for k in range(N)) for i in range(N)]
    return Zbasis_J


def is_in_lattice(B,Zbasis_I,x):
    """
    INPUT :
        -- B -- a central simple algebra over Q of dimension N
        -- Zbasis_I -- a list [e1,..,eN] which is a Q-basis of B and representing the lattice I := Ze1⊕... ⊕ZeN 
        -- x -- an element of B
    OUTPUT :
        -- boolean -- True if x is in B, False otherwise.
    """
    coords = coordinate(x,B,Zbasis_I)
    for r in coords:
        if r not in ZZ:
            return False
    return True


def is_sub_lattice(B,Zbasis_I,Zbasis_J):
    """
    INPUT :
        -- B -- a central simple algebra over Q of dimension N
        -- Zbasis_I -- a list [e1,..,eN] which is a Q-basis of B and representing the lattice I := Ze1⊕... ⊕ZeN 
        -- Zbasis_I -- a list [f1,..,fN] which is a Q-basis of B and representing the lattice I := Zf1⊕... ⊕ZfN 
    OUTPUT :
        -- boolean -- True if I is a sublattice of J, False otehrwise
    """
    mat_I_can = change_matrix(B,Zbasis_I)
    mat_can_J = change_matrix(B,Zbasis_J).inverse()
    mat_I_J = mat_I_can*mat_can_J
    return mat_I_J.denominator() == 1


def is_order(B,Zbasis_I):
    """
    INPUT :
        -- B -- a central simple algebra over Q of dimension N
        -- Zbasis_I -- a list [e1,..,eN] which is a Q-basis of B and representing the lattice I := Ze1⊕... ⊕ZeN
    OUTPUT :
        -- boolean -- True if I is an order of B
    """
    if not is_in_lattice(B,Zbasis_I,B.one()):
        return False

    for e in Zbasis_I:
        for f in Zbasis_I:
            x = f*e
            if not is_in_lattice(B,Zbasis_I,x):
                return False
    return True


def are_equals_lattices(B,Zbasis_I,Zbasis_J):
    """
    INPUT :
        -- B -- a central simple algebra over Q of dimension N
        -- Zbasis_I -- a list [e1,..,eN] which is a Q-basis of B and representing the lattice I := Ze1⊕... ⊕ZeN 
        -- Zbasis_I -- a list [f1,..,fN] which is a Q-basis of B and representing the lattice I := Zf1⊕... ⊕ZfN 
    OUTPUT :
        -- boolean -- True if I is a sublattice of J, False otehrwise
    """
    mat_I_can = change_matrix(B,Zbasis_I)
    mat_can_J = change_matrix(B,Zbasis_J).inverse()
    mat_I_J = mat_I_can*mat_can_J
    mat_J_I = (mat_I_J).inverse()
    return mat_I_J.denominator() == 1 and mat_J_I.denominator() == 1



def left_order(B,Zbasis_I,reduced = True):
    """
    INPUT :
        -- B -- a central simple algebra over Q given by structure constant of dimension N
        -- Zbasis_I -- a list [e1,..,eN]  which is a Q-basis of B representing the 
                       Z-lattice I = Ze1⊕... ⊕ZeN
    OUTPUT :
        -- Zbasis_O -- a list [f1,..,fN]  which is a Q-basis of B representing the 
                       Z-order O = Zf1⊕... ⊕ZfN such that O=O_L(I)
    Algorithm Description
    ---------------------
    1. **Structure Constants Setup**:
       - We compute cjik such that: e_i * e_j = sum(c_jik * e_k for k=1 to N)
       - Note: j and i indices are swapped due to Sage structure constant conventions
       - a priori cjik in Q since I is not suppose to be an order
    
    2. **Construct Element s**:
       - Comput s in Z such that s in I = Ze1 ⊕ Ze2 ⊕ ... ⊕ ZeN
       - This element defines the scaling factor for the final basis
    
    3. **Build Matrix T**:
       - Dimensions: N^2 rows N columns
       - Structure: T = (1/s) * [c_111 ... c_1N1]
                                [c_112 ... c_1N2]
                                [  .   ...   .  ]
                                [c_11N ... c_1NN]
                                [  .   ...   .  ]
                                [c_N11 ... c_NN1]
                                [  .   ...   .  ]
                                [c_N1N ... c_NNN]
    
    4. **Integer Matrix Construction**:
       - Compute d = denominator(T) (LCM of all denominators in T)
       - Set A = d * T to obtain an integer matrix
    
    5. **Main Congruence System**:
       - Goal: Solve A*X ≡ 0 (mod d) for X in Z^N
       - The solution set forms a free Z-submodule of Z^N
       - Find Z-basis X = [X1,..,XN] Xi in Z^N (we know the lenght is N for theorical background on left order)
       - For this I use my improve algorithm X = kernel_mod(A,d) which split the huge matrix A in block
          the apply a Smith Reduction and then intersect the submodule kernel of each block
          using an inner SageMath method on Z-modul that I hope is efficient.
    
    9. **Final Left Order Basis**:
       - Transform solutions back to algebra elements:
         Left Order Basis = {(1/s) * x_1*(e_1,...,e_N), 
                            (1/s) * x_2*(e_1,...,e_N),
                            ...,
                            (1/s) * x_N*(e_1,...,e_N)}
       - Where X*(e_1,...,e_N) = x_1*e_1 + x_2*e_2 + ... + x_N*e_N
    """
    N = dimension(B)
    one_B = B.one()

    mat_I_can = change_matrix(B,Zbasis_I)
    mat_can_I = mat_I_can.inverse()

    coords_one_can = vector(QQ,get_coefficients(one_B,B))
    coords_one_I = coords_one_can*mat_can_I
    s = lcm([r.denominator() for r in coords_one_I])


    C = structure_constants(B,Zbasis_I,mat_inv = mat_can_I)

    rows = []
    for j in range(N):
        for k in range(N):
            rowjk = []
            for i in range(N):
                rowjk.append(C[j][i][k]/s)
            rows.append(rowjk)
    M = Matrix(QQ,rows)
    d = lcm([a.denominator() for a in M.list()])
    A = d*M

    A = Matrix(ZZ,A)
    X = kernel_mod(A,d) # Z-basis of solution of MX = 0 mod d

    Zbasis_OLI = [(1/s) * sum(X[i][k] * Zbasis_I[k] for k in range(N)) for i in range(N)]

    return lattice_LLL(B,Zbasis_OLI)
        








## Reduced trace and discriminant

def reduced_trace(B,x):
    """
    INPUT :
        -- B -- a central simple algebra given by structure constant
        -- x -- an element of B
    OUTPUT :
        -- t -- the reduced trace of x = 1/n*trace (b ->xb) where n i such that dim B = n^2
    """
    basis_B = list(B.basis())
    N = dimension(B)
    n = int(sqrt(N))

    trd = 0
    for i in range(N):
        coords = get_coefficients(x*basis_B[i],B)
        trd = trd + coords[i]
    
    trd = trd/n
    return trd

def discriminant(B,Zbasis_I):
    """
    INPUT :
        -- B -- a finite dimensional central simple algebra over Q
        -- Zbasis_I -- a list [e1,..,eN] which is a Q-basis of B and representing the lattice I := Ze1⊕... ⊕ZeN 
    OUTPUT :
        -- d -- in Z the discriminant of I (modulo +-1).
    """
    N = dimension(B)
    basis_B = B.basis()
    e = Zbasis_I
    trd_basis = []
    for i in range(N):
        trd_basis.append(reduced_trace(B,basis_B[i]))
    rows = []
    for i in range(N):
        row = []
        for j in range(N):
            x = e[i]*e[j]
            coords = get_coefficients(x,B)
            trd_eiej = sum(coords[k]*trd_basis[k] for k in range(N))
            row.append(trd_eiej)
        rows.append(row)
    M = Matrix(QQ,rows)
    return M.determinant()
            








## Quotient of algebra and kernel of Z module map



def finite_algebra_from_order(B,Zbasis_O,p):
    """
    INPUT :
        -- b -- a central simple algebra over Q of dimension N
        -- Zbasis_O -- a list [e1,..,eN] which is a Q-basis of B and such that O := Ze1⊕... ⊕ZeN is a Z-order of B
    OUTPUT :
        -- A -- an instance of FiniteDimensional algebra representing the finite Fp-algebra A = Fp e1⊕... ⊕Fp eN with the multiplication from O
        -- pi -- a lambda function [0,..,N-1] -> A which represent pi : Z^n -> A the abelian group homomrohism O -> A : pi(i) = fi = ei in A
    """
    mat_O_can = change_matrix(B,Zbasis_O)
    mat_can_O = mat_O_can.inverse()
    table = []
    for e in Zbasis_O:
        rows = []
        for f in Zbasis_O:
            x = f*e
            coords_can = vector(QQ,get_coefficients(x,B))
            coords_O = coords_can*mat_can_O
            coords_mod_p = [GF(p)(a) for a in coords_O]
            rows.append(coords_mod_p)
        M = Matrix(GF(p), rows)
        table.append(M)

    cat = AlgebrasWithBasis(GF(p)).Associative().FiniteDimensional()
    A = FiniteDimensionalAlgebra(GF(p),table,category=cat)
    f = A.basis() # fi = ei view in A
    pi = lambda i : f[i]
    return A,pi


def quotient_algebra_ideal(A,basis_I):
    """
    INPUT : 
        -- A -- a finite dimensional algebra given by structure constants (over a finite field in our case)
        -- I -- a list of element of A representing a basis of an ideal I
    OUTPUT :
        -- C -- a finite dimensional algebra given by structure constant represnting A/I
        -- pi -- function A ->C  representing the projection A ->A/I
    """

    I = A.ideal(basis_I)
    pi = A.quotient_map(I)
    C = pi.codomain()
    return C,pi


def kernel_Z_mod_map(C, phi,N):
    """
    INPUT:
        -- C -- a finite-dimensional algebra over a finite field, given by structure constants.
        -- phi -- a function from [0, ..., N-1] to C representing a Z-module homomorphism φ: Z^N → C.

    OUTPUT:
        -- basis_Ker --: a list of vectors in Z^N forming a Z-basis of the kernel of φ.
    """

    # Determine the dimension M of the codomain C
    M = C.dimension()
    p = C.base_ring().order()

    # Initialize an empty list to store the columns of the matrix representation of φ
    columns = []

    # For each basis element e_i of ℤ^N, compute φ(e_i) and express it as a vector in C
    for i in range(N):
        phi_ei = phi(i)
        coords = get_coefficients(phi_ei, C) # cooridnate in Fp 
        coords_int = [int(c) for c in coords]
        columns.append(coords_int)

    # Construct the matrix representation of φ over ℤ
    M_matrix = Matrix(ZZ, columns).transpose()

    # Extract the basis vectors of the kernel
    basis_Ker =  kernel_mod(M_matrix,p)

    return basis_Ker


